---
import {
  getConvexUrl,
  getUserParks,
  getAvailableParks,
  getUserEntitlements,
} from "../lib/convexClient";
import { UserButton } from "@clerk/astro/components";
import PageLayout from "../layouts/PageLayout.astro";

// Auth check
const { userId, getToken } = Astro.locals.auth();
if (!userId) {
  return Astro.redirect("/sign-in");
}

const token = await getToken({ template: "convex" });
if (!token) {
  return Astro.redirect("/sign-in");
}

const convexUrl = getConvexUrl();

// Fetch parks and entitlements server-side
const [userParks, availableParks, entitlements] = await Promise.all([
  getUserParks(token),
  getAvailableParks(token),
  getUserEntitlements(token).catch((err) => {
    console.error("Failed to fetch entitlements:", err);
    return null;
  }),
]);

// Calculate limits for display
const isFreeUser = entitlements?.tier === "free";
const maxParks = entitlements?.limits.maxParks ?? -1;
const currentParkCount = userParks.length;
const canAddPark = entitlements?.canAddPark ?? true;
const isAtLimit = !canAddPark && isFreeUser;
---

<PageLayout
  title="Manage Parks"
  subtitle="Add or remove parks from your list"
  pageTitle="Manage Parks"
  backLink={{ href: "/app" }}
  showUserButton
>
  <UserButton.Link slot="user-menu" label="Account" href="/account">
    <svg
      slot="label-icon"
      xmlns="http://www.w3.org/2000/svg"
      viewBox="0 0 24 24"
      fill="currentColor"
      width="16"
      height="16"
    >
      <path
        d="M12 12c2.21 0 4-1.79 4-4s-1.79-4-4-4-4 1.79-4 4 1.79 4 4 4zm0 2c-2.67 0-8 1.34-8 4v2h16v-2c0-2.66-5.33-4-8-4z"
      ></path>
    </svg>
  </UserButton.Link>

  {/* Upgrade prompt when limit reached */}
  {
    isAtLimit && (
      <div
        id="limit-banner"
        class="from-sunset/20 to-gold/20 border-sunset/30 mb-4 rounded-2xl border bg-gradient-to-r p-4 text-center"
      >
        <p class="text-cream mb-2 font-medium">You've reached your park limit!</p>
        <p class="text-mist mb-3 text-sm">
          Free accounts can save up to {maxParks} parks. Upgrade to Premium for unlimited parks.
        </p>
        <a
          href="/pricing"
          class="bg-gold text-forest hover:bg-cream inline-flex items-center gap-2 rounded-full px-4 py-2 font-semibold transition-colors"
        >
          <span>⭐</span>
          <span>Upgrade to Premium</span>
        </a>
      </div>
    )
  }

  <div class="space-y-8">
    <!-- My Parks Section -->
    <section>
      <div class="mb-4 flex items-center justify-between">
        <h2 class="text-cream font-[Fraunces] text-xl">
          My Parks ({currentParkCount}{isFreeUser && maxParks > 0 ? `/${maxParks}` : ""})
        </h2>
        <span
          id="location-status"
          class="text-mist flex items-center gap-1.5 text-xs opacity-0 transition-opacity duration-300"
        >
          <span id="location-status-icon"></span>
          <span id="location-status-text"></span>
        </span>
      </div>

      {
        userParks.length === 0 ? (
          <div
            data-empty-message
            class="rounded-2xl border border-white/15 bg-white/10 p-6 text-center backdrop-blur-xl"
          >
            <p class="text-mist">No parks yet. Add some below to get started.</p>
          </div>
        ) : (
          <div class="grid gap-3" id="my-parks-grid">
            {userParks.map((park: any) => (
              <article
                class="park-card bg-cream flex items-center justify-between gap-4 rounded-xl p-4 transition-opacity duration-200"
                data-park-id={park.parkId}
                data-place-id={park.placeId}
              >
                <div class="min-w-0 flex-1">
                  <h3 class="text-forest truncate font-[Fraunces] font-semibold">{park.name}</h3>
                  {park.customName && <p class="text-sunset truncate text-sm">{park.customName}</p>}
                  {park.address && <p class="text-moss truncate text-sm">{park.address}</p>}
                  <div class="mt-1 flex flex-wrap items-center gap-2">
                    {park.visitCount > 0 && (
                      <span class="bg-gold/20 text-forest inline-block rounded-full px-2 py-0.5 text-xs">
                        {park.visitCount} visit{park.visitCount !== 1 ? "s" : ""}
                      </span>
                    )}
                    <span
                      class="distance-badge text-moss hidden text-xs"
                      data-distance-for={park.placeId}
                    />
                  </div>
                </div>
                <button
                  class="remove-btn bg-sunset/10 hover:bg-sunset/20 text-sunset flex h-11 w-11 shrink-0 items-center justify-center rounded-full transition-colors"
                  data-remove={park.parkId}
                  aria-label={`Remove ${park.name}`}
                >
                  <svg class="h-5 w-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path
                      stroke-linecap="round"
                      stroke-linejoin="round"
                      stroke-width="2"
                      d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"
                    />
                  </svg>
                </button>
              </article>
            ))}
          </div>
        )
      }
    </section>

    <!-- Available Parks Section -->
    <section>
      <h2 class="text-cream mb-4 font-[Fraunces] text-xl">
        Add Parks ({availableParks.length})
      </h2>

      {
        availableParks.length === 0 ? (
          <div class="rounded-2xl border border-white/15 bg-white/10 p-6 text-center backdrop-blur-xl">
            <p class="text-mist">You've added all available parks!</p>
          </div>
        ) : (
          <div class="grid gap-3" id="add-parks-grid">
            {availableParks.map((park: any) => (
              <article
                class="park-card flex items-center justify-between gap-4 rounded-xl border border-white/15 bg-white/10 p-4 backdrop-blur-xl transition-opacity duration-200"
                data-available-id={park._id}
                data-place-id={park.placeId}
              >
                <div class="min-w-0 flex-1">
                  <h3 class="text-cream truncate font-[Fraunces] font-semibold">{park.name}</h3>
                  {park.customName && <p class="text-gold truncate text-sm">{park.customName}</p>}
                  {park.address && <p class="text-mist truncate text-sm">{park.address}</p>}
                  <span
                    class="distance-badge text-mist mt-1 hidden text-xs"
                    data-distance-for={park.placeId}
                  />
                </div>
                <button
                  class={`add-btn flex h-11 w-11 shrink-0 items-center justify-center rounded-full transition-colors ${
                    isAtLimit
                      ? "bg-mist/10 text-mist/50 cursor-not-allowed"
                      : "bg-gold/20 hover:bg-gold/30 text-gold"
                  }`}
                  data-add={park._id}
                  aria-label={`Add ${park.name}`}
                  disabled={isAtLimit}
                >
                  <svg class="h-6 w-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path
                      stroke-linecap="round"
                      stroke-linejoin="round"
                      stroke-width="2"
                      d="M12 4v16m8-8H4"
                    />
                  </svg>
                </button>
              </article>
            ))}
          </div>
        )
      }
    </section>
  </div>

  <footer slot="footer" class="mt-8 space-y-2 text-center">
    <p class="text-mist text-sm opacity-80">
      <a href="/discover" class="text-gold hover:text-cream font-semibold transition-colors"
        >Discover nearby parks &rarr;</a
      >
    </p>
    <p class="text-mist text-sm opacity-80">
      <a href="/app" class="text-gold hover:text-cream font-semibold transition-colors"
        >Pick a park &rarr;</a
      >
    </p>
    <nav class="text-mist mt-4 flex justify-center gap-6 border-t border-white/10 pt-4 text-sm">
      <a href="/about" class="hover:text-cream transition-colors">About</a>
      <a href="/help" class="hover:text-cream transition-colors">Help</a>
      <a href="/legal/terms" class="hover:text-cream transition-colors">Terms</a>
      <a href="/legal/privacy" class="hover:text-cream transition-colors">Privacy</a>
    </nav>
  </footer>

  <script slot="scripts" define:vars={{ convexUrl, convexToken: token, isFreeUser, maxParks }}>
    // Track current park count for dynamic limit checking
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    let currentCount = 0;

    // Helper to check if error message indicates a limit error
    function isLimitError(errorMessage) {
      if (!errorMessage) return false;
      return (
        errorMessage.includes("PARK_LIMIT_EXCEEDED") ||
        errorMessage.includes("park limit") ||
        errorMessage.includes("Maximum parks")
      );
    }

    // Helper to escape HTML for safe insertion
    function escapeHtml(text) {
      if (!text) return "";
      const div = document.createElement("div");
      div.textContent = text;
      return div.innerHTML;
    }

    // Create a card element for "My Parks" section
    function createMyParkCard(park) {
      const article = document.createElement("article");
      article.className =
        "park-card bg-cream flex items-center justify-between gap-4 rounded-xl p-4 transition-opacity duration-200";
      article.dataset.parkId = park.parkId;
      if (park.placeId) {
        article.dataset.placeId = park.placeId;
      }

      // Build inner HTML
      let html = `
        <div class="min-w-0 flex-1">
          <h3 class="text-forest truncate font-[Fraunces] font-semibold">${escapeHtml(park.name)}</h3>`;

      if (park.customName) {
        html += `<p class="text-sunset truncate text-sm">${escapeHtml(park.customName)}</p>`;
      }
      if (park.address) {
        html += `<p class="text-moss truncate text-sm">${escapeHtml(park.address)}</p>`;
      }

      // Distance badge + visit count container
      html += `<div class="mt-1 flex flex-wrap items-center gap-2">`;
      // New parks have visitCount = 0, so no badge needed
      // Distance badge placeholder (will be populated if distance data is available)
      if (park.placeId) {
        const existingDistance = distanceData.get(park.placeId);
        if (existingDistance && existingDistance !== Infinity) {
          // If we already have distance data, show it
          const distanceText =
            document.querySelector(`[data-distance-for="${park.placeId}"]`)?.textContent || "";
          if (distanceText) {
            html += `<span class="distance-badge text-moss text-xs" data-distance-for="${escapeHtml(park.placeId)}">${escapeHtml(distanceText)}</span>`;
          } else {
            html += `<span class="distance-badge text-moss hidden text-xs" data-distance-for="${escapeHtml(park.placeId)}"></span>`;
          }
        } else {
          html += `<span class="distance-badge text-moss hidden text-xs" data-distance-for="${escapeHtml(park.placeId)}"></span>`;
        }
      }
      html += `</div>`;

      html += `</div>
        <button
          class="remove-btn bg-sunset/10 hover:bg-sunset/20 text-sunset flex h-11 w-11 shrink-0 items-center justify-center rounded-full transition-colors"
          data-remove="${escapeHtml(park.parkId)}"
          aria-label="Remove ${escapeHtml(park.name)}"
        >
          <svg class="h-5 w-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16" />
          </svg>
        </button>`;

      article.innerHTML = html;
      return article;
    }

    // Add a park card to the "My Parks" section with animation
    function addParkToMyParksSection(park) {
      const myParksSection = document.querySelector("section:first-of-type");
      if (!myParksSection) return;

      // Check if there's an "empty" message div and remove it
      const emptyMessage = myParksSection.querySelector("[data-empty-message]");
      if (emptyMessage) {
        // Replace with a grid container
        const grid = document.createElement("div");
        grid.className = "grid gap-3";
        grid.id = "my-parks-grid";
        emptyMessage.replaceWith(grid);
      }

      // Find the grid container
      let grid = myParksSection.querySelector(".grid");
      if (!grid) {
        grid = document.createElement("div");
        grid.className = "grid gap-3";
        grid.id = "my-parks-grid";
        const h2 = myParksSection.querySelector("h2");
        if (h2) {
          h2.after(grid);
        } else {
          myParksSection.appendChild(grid);
        }
      }

      // Create and animate the new card
      const card = createMyParkCard(park);
      card.style.opacity = "0";
      card.style.transform = "translateX(-20px)";
      grid.prepend(card);

      // Attach remove handler to the new button
      const removeBtn = card.querySelector(".remove-btn");
      if (removeBtn) {
        attachRemoveHandler(removeBtn);
      }

      // Trigger animation
      requestAnimationFrame(() => {
        card.style.transition = "opacity 200ms, transform 200ms";
        card.style.opacity = "1";
        card.style.transform = "translateX(0)";
      });
    }

    // Attach remove handler to a button (extracted for reuse)
    function attachRemoveHandler(btn) {
      btn.addEventListener("click", async (e) => {
        const button = e.currentTarget;
        const parkId = button.dataset.remove;
        const card = button.closest(".park-card");

        button.disabled = true;
        button.innerHTML =
          '<span class="w-4 h-4 border-2 border-sunset border-t-transparent rounded-full animate-spin"></span>';

        try {
          const response = await fetch(`${convexUrl}/api/mutation`, {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
              Authorization: `Bearer ${convexToken}`,
            },
            body: JSON.stringify({
              path: "userParks:removeParkFromUserList",
              args: { parkId },
              format: "json",
            }),
          });
          const result = await response.json();
          if (result.status === "error") {
            throw new Error(result.errorMessage || "Failed to remove park");
          }

          // Optimistic UI: fade out and remove card
          card.style.opacity = "0";
          card.style.transform = "translateX(-20px)";
          setTimeout(() => {
            card.remove();
            updateCounts();
          }, 200);
        } catch (err) {
          console.error("Failed to remove park:", err);
          button.disabled = false;
          button.innerHTML =
            '<svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16" /></svg>';
        }
      });
    }

    // Helper to update section counts
    function updateCounts() {
      const myParksSection = document.querySelector("section:first-of-type");
      const addParksSection = document.querySelector("section:last-of-type");

      const myParksCount = myParksSection?.querySelectorAll(".park-card").length || 0;
      const addParksCount = addParksSection?.querySelectorAll(".park-card").length || 0;

      currentCount = myParksCount;

      const myParksHeader = myParksSection?.querySelector("h2");
      const addParksHeader = addParksSection?.querySelector("h2");

      if (myParksHeader) {
        myParksHeader.textContent =
          isFreeUser && maxParks > 0
            ? `My Parks (${myParksCount}/${maxParks})`
            : `My Parks (${myParksCount})`;
      }
      if (addParksHeader) addParksHeader.textContent = `Add Parks (${addParksCount})`;

      // Check if at limit and disable/enable add buttons accordingly
      if (isFreeUser && maxParks > 0 && myParksCount >= maxParks) {
        document.querySelectorAll(".add-btn").forEach((btn) => {
          btn.disabled = true;
          btn.classList.remove("bg-gold/20", "hover:bg-gold/30", "text-gold");
          btn.classList.add("bg-mist/10", "text-mist/50", "cursor-not-allowed");
        });
      } else {
        // Re-enable add buttons when below limit
        document.querySelectorAll(".add-btn").forEach((btn) => {
          btn.disabled = false;
          btn.classList.remove("bg-mist/10", "text-mist/50", "cursor-not-allowed");
          btn.classList.add("bg-gold/20", "hover:bg-gold/30", "text-gold");
        });
      }
    }

    // Show limit error UI
    function showLimitError() {
      // Show a toast or banner
      const existingBanner = document.getElementById("limit-banner");
      if (!existingBanner) {
        const banner = document.createElement("div");
        banner.id = "limit-banner";
        banner.className =
          "bg-gradient-to-r from-sunset/20 to-gold/20 border border-sunset/30 rounded-2xl p-4 mb-4 text-center";
        banner.innerHTML = `
          <p class="text-cream font-medium mb-2">You've reached your park limit!</p>
          <p class="text-mist text-sm mb-3">Free accounts can save up to ${maxParks} parks. Upgrade to Premium for unlimited parks.</p>
          <a
            href="/pricing"
            class="inline-flex items-center gap-2 bg-gold text-forest font-semibold px-4 py-2 rounded-full hover:bg-cream transition-colors"
          >
            <span>⭐</span>
            <span>Upgrade to Premium</span>
          </a>
        `;
        const main = document.querySelector("main");
        main.parentNode.insertBefore(banner, main);
      }
    }

    // Handle add park with optimistic UI
    document.querySelectorAll(".add-btn").forEach((btn) => {
      btn.addEventListener("click", async (e) => {
        const button = e.currentTarget;
        const parkId = button.dataset.add;
        const card = button.closest(".park-card");

        // Prevent action if already at limit
        if (button.disabled) return;

        button.disabled = true;
        button.innerHTML =
          '<span class="w-4 h-4 border-2 border-gold border-t-transparent rounded-full animate-spin"></span>';

        try {
          const response = await fetch(`${convexUrl}/api/mutation`, {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
              Authorization: `Bearer ${convexToken}`,
            },
            body: JSON.stringify({
              path: "userParks:addParkToUserList",
              args: { parkId },
              format: "json",
            }),
          });
          const result = await response.json();
          if (result.status === "error") {
            throw new Error(result.errorMessage || "Failed to add park");
          }

          // Add park to "My Parks" section
          if (result.value && result.value.park) {
            addParkToMyParksSection(result.value.park);
          }

          // Optimistic UI: fade out and remove card from "Add Parks" section
          card.style.opacity = "0";
          card.style.transform = "translateX(20px)";
          setTimeout(() => {
            card.remove();
            updateCounts();
          }, 200);
        } catch (err) {
          console.error("Failed to add park:", err);

          // Reset button state BEFORE checking error type
          // This ensures button is never stuck in spinner state
          button.disabled = false;
          button.innerHTML =
            '<svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 4v16m8-8H4" /></svg>';

          // Check if this is a limit error and show appropriate UI
          if (isLimitError(err.message)) {
            showLimitError();
            updateCounts(); // Will disable all add buttons if at limit
          }
        }
      });
    });

    // Handle remove park with optimistic UI
    document.querySelectorAll(".remove-btn").forEach((btn) => {
      attachRemoveHandler(btn);
    });

    // ============================================================
    // Distance Display Feature
    // ============================================================

    // Store distances for sorting (placeId -> distance in miles as number)
    const distanceData = new Map();

    // Parse distance text to miles number (e.g., "5.2 mi" -> 5.2)
    function parseDistanceToMiles(distanceText) {
      if (!distanceText) return Infinity;
      const match = distanceText.match(/([\d.]+)\s*(mi|ft)/i);
      if (!match) return Infinity;
      const value = parseFloat(match[1]);
      const unit = match[2].toLowerCase();
      // Convert feet to miles if needed
      return unit === "ft" ? value / 5280 : value;
    }

    // Update distance badge for a placeId
    function updateDistanceBadge(placeId, distanceText) {
      const badges = document.querySelectorAll(`[data-distance-for="${placeId}"]`);
      badges.forEach((badge) => {
        badge.textContent = distanceText;
        badge.classList.remove("hidden");
      });
      // Store for sorting
      distanceData.set(placeId, parseDistanceToMiles(distanceText));
    }

    // Sort "Add Parks" section by distance (closest first)
    function sortAddParksByDistance() {
      const grid = document.getElementById("add-parks-grid");
      if (!grid) return;

      const cards = Array.from(grid.querySelectorAll(".park-card"));
      if (cards.length === 0) return;

      // Sort cards by distance (closest first)
      cards.sort((a, b) => {
        const placeIdA = a.dataset.placeId;
        const placeIdB = b.dataset.placeId;
        const distA = distanceData.get(placeIdA) ?? Infinity;
        const distB = distanceData.get(placeIdB) ?? Infinity;
        return distA - distB;
      });

      // Re-append cards in sorted order (this preserves event listeners)
      cards.forEach((card) => grid.appendChild(card));
    }

    // Fetch distances in batches
    async function fetchDistances(placeIds, originLat, originLng) {
      // Batch into groups of 25 (API limit)
      const batches = [];
      for (let i = 0; i < placeIds.length; i += 25) {
        batches.push(placeIds.slice(i, i + 25));
      }

      // Fetch all batches in parallel using Astro Actions
      const batchPromises = batches.map(async (batch) => {
        try {
          const response = await fetch("/_actions/getBatchTravelTime", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({
              originLat,
              originLng,
              placeIds: batch,
            }),
          });

          if (!response.ok) {
            console.error("Failed to fetch batch distances:", response.status);
            return {};
          }

          const result = await response.json();
          // Astro Actions wrap result in { data } or { error }
          return result.data || {};
        } catch (err) {
          console.error("Error fetching batch distances:", err);
          return {};
        }
      });

      const results = await Promise.all(batchPromises);

      // Merge all results
      const allDistances = {};
      results.forEach((batchResult) => {
        Object.assign(allDistances, batchResult);
      });

      return allDistances;
    }

    // Location status UI helpers
    const locationStatus = document.getElementById("location-status");
    const locationIcon = document.getElementById("location-status-icon");
    const locationText = document.getElementById("location-status-text");

    function showLocationStatus(icon, text, isError = false) {
      if (!locationStatus || !locationIcon || !locationText) return;
      locationIcon.innerHTML = icon;
      locationText.textContent = text;
      locationStatus.classList.toggle("text-sunset", isError);
      locationStatus.classList.toggle("text-mist", !isError);
      locationStatus.classList.remove("opacity-0");
    }

    function hideLocationStatus() {
      if (!locationStatus) return;
      locationStatus.classList.add("opacity-0");
    }

    // Initialize distance fetching
    async function initDistances() {
      // Collect all unique placeIds from park cards
      const placeIds = new Set();
      document.querySelectorAll("[data-place-id]").forEach((el) => {
        const placeId = el.dataset.placeId;
        if (placeId) placeIds.add(placeId);
      });

      if (placeIds.size === 0) return;

      // Request geolocation
      if (!navigator.geolocation) {
        showLocationStatus(
          '<svg class="w-3 h-3" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M17.657 16.657L13.414 20.9a1.998 1.998 0 01-2.827 0l-4.244-4.243a8 8 0 1111.314 0z"/></svg>',
          "Location not supported",
          true
        );
        return;
      }

      // Show loading state
      showLocationStatus(
        '<span class="w-3 h-3 border-2 border-mist border-t-cream rounded-full animate-spin inline-block"></span>',
        "Fetching location..."
      );

      navigator.geolocation.getCurrentPosition(
        async (position) => {
          const { latitude, longitude } = position.coords;

          // Update status while fetching distances
          showLocationStatus(
            '<span class="w-3 h-3 border-2 border-mist border-t-cream rounded-full animate-spin inline-block"></span>',
            "Calculating distances..."
          );

          // Fetch all distances
          const distances = await fetchDistances(Array.from(placeIds), latitude, longitude);

          // Update UI with distance badges
          for (const [placeId, result] of Object.entries(distances)) {
            if (result && result.distanceText) {
              updateDistanceBadge(placeId, result.distanceText);
            }
          }

          // Sort "Add Parks" section by distance
          sortAddParksByDistance();

          // Hide status after success (brief flash to show completion)
          setTimeout(hideLocationStatus, 1500);
        },
        (error) => {
          // Show user-friendly error
          let errorText = "Location unavailable";
          if (error.code === error.PERMISSION_DENIED) {
            errorText = "Location access denied";
          } else if (error.code === error.TIMEOUT) {
            errorText = "Location timed out";
          }
          showLocationStatus(
            '<svg class="w-3 h-3" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M17.657 16.657L13.414 20.9a1.998 1.998 0 01-2.827 0l-4.244-4.243a8 8 0 1111.314 0z"/></svg>',
            errorText,
            true
          );
        },
        { enableHighAccuracy: false, timeout: 10000 }
      );
    }

    // Start fetching distances when page loads
    initDistances();
  </script>
</PageLayout>
